---
description: Django Migration Standards - Safe Database Schema Changes
globs: **/migrations/*.py
alwaysApply: false
---
# Django Migration Standards

## üìã Overview

Django migrations are a way to propagate changes made to models into the database schema. This rule defines best practices for creating safe, reversible, and production-ready migrations that maintain data integrity and minimize downtime.

> **Django Version**: This guide follows Django 6.x best practices and migration patterns.

## üìö Related Rules

For specific implementation cases, see:

- [Data Migrations](django-migrations-data.mdc) - Detailed patterns for data migrations, batch processing, error handling, and conditional migrations
- [Production Strategies](django-migrations-production.mdc) - Two-phase deployment, concurrent indexes, transaction safety, and production testing
- [Advanced Patterns](django-migrations-advanced.mdc) - Raw SQL, Foreign Keys, ManyToMany fields, Unique Constraints, and Renaming operations


## üìÅ Migration File Conventions

### Naming Pattern

Django automatically generates migration files with the format:
```
{number}_{name}.py  # 0001_initial.py, 0002_add_user_email.py
```

### Standard Migration Structure

```python
# Generated by Django on 'makemigrations'
from django.db import migrations, models
import django.utils.timezone

class Migration(migrations.Migration):
    """
    Initial migration for User model.
    
    Creates User table with email, username, and timestamps.
    Adds indexes for efficient queries.
    """
    initial = True  # Marks as initial migration

    dependencies = [
        # No dependencies for initial migration
    ]

    operations = [
        migrations.CreateModel(
            name='User',
            fields=[
                ('id', models.BigAutoField(
                    auto_created=True, 
                    primary_key=True, 
                    serialize=False, 
                    verbose_name='ID'
                )),
                ('email', models.EmailField(
                    max_length=255, 
                    unique=True,
                    db_index=True,
                )),
                ('username', models.CharField(
                    max_length=50, 
                    unique=True,
                )),
                ('created_at', models.DateTimeField(
                    default=django.utils.timezone.now,
                    editable=False,
                )),
                ('updated_at', models.DateTimeField(
                    auto_now=True,
                )),
            ],
            options={
                'db_table': 'users',
                'ordering': ['-created_at'],
            },
        ),
        migrations.CreateIndex(
            model_name='user',
            index=models.Index(
                fields=['email'], 
                name='users_email_idx'
            ),
        ),
    ]
```

## ‚úÖ DO (Recommended Practices)

### 1. Use Descriptive Migration Names

Always use the `--name` flag when creating migrations to provide meaningful names:

```bash
# ‚úÖ Good: descriptive name
python manage.py makemigrations --name add_user_email_field

# ‚ùå Bad: auto-generated name
python manage.py makemigrations  # Creates 0002_auto_20240115_1234.py
```

### 2. Write Reversible Migrations

Always ensure migrations can be rolled back safely:

```python
# ‚úÖ Good: reversible migration with dependencies
from django.db import migrations, models

class Migration(migrations.Migration):
    """
    Add middle_name field and remove deprecated old_field.
    
    This migration is fully reversible - Django automatically
    handles the reverse operations for AddField and RemoveField.
    """
    dependencies = [
        ('myapp', '0001_initial'),  # Previous migration
    ]

    operations = [
        migrations.AddField(
            model_name='user',
            name='middle_name',
            field=models.CharField(
                max_length=50, 
                null=True, 
                blank=True,
                help_text='User middle name (optional)',
            ),
        ),
        migrations.RemoveField(
            model_name='user',
            name='old_field',  # Field removed after deprecation period
        ),
    ]
```

### 3. Use Historical Models in Data Migrations

Always use `apps.get_model()` to access models in data migrations. Historical models only have fields that existed at that migration point:

```python
# ‚úÖ Good: using historical models
from django.db import migrations

def forwards_func(apps, schema_editor):
    """Populate full_name field from component fields."""
    User = apps.get_model('myapp', 'User')
    
    for user in User.objects.all().iterator():
        user.full_name = f"{user.first_name} {user.last_name}"
        user.save(update_fields=['full_name'])

def reverse_func(apps, schema_editor):
    """Clear full_name field on rollback."""
    User = apps.get_model('myapp', 'User')
    User.objects.all().update(full_name=None)

class Migration(migrations.Migration):
    dependencies = [
        ('myapp', '0001_add_full_name_field'),
    ]

    operations = [
        migrations.RunPython(forwards_func, reverse_func),
    ]
```

### 4. Separate Schema and Data Migrations

Keep schema changes and data migrations separate. This allows:
- Testing schema changes independently
- Re-running data migrations if needed
- Better error isolation

```python
# ‚úÖ Migration 1: Schema change only
class Migration(migrations.Migration):
    operations = [
        migrations.AddField(
            model_name='user',
            name='full_name',
            field=models.CharField(max_length=255, null=True, blank=True),
        ),
    ]

# ‚úÖ Migration 2: Data migration (separate file)
def populate_full_name(apps, schema_editor):
    User = apps.get_model('myapp', 'User')
    for user in User.objects.all().iterator():
        if user.first_name and user.last_name:
            user.full_name = f"{user.first_name} {user.last_name}"
            user.save(update_fields=['full_name'])
```

### 5. Test Migrations Thoroughly

Always test both forward and backward migrations:

```bash
# ‚úÖ Test forward migration
python manage.py migrate

# ‚úÖ Test backward migration (rollback)
python manage.py migrate myapp 0001

# ‚úÖ Test forward again
python manage.py migrate

# ‚úÖ Check migration status
python manage.py showmigrations
```

### 6. Handle Migration Conflicts

Use `--merge` to resolve migration conflicts:

```bash
# ‚úÖ Merge conflicting migrations
python manage.py makemigrations --merge
```

### 7. Commit Migration Files to Version Control

Always commit migration files to maintain consistency:

```bash
# ‚úÖ Commit migrations
git add myapp/migrations/
git commit -m "Add user email field migration"
```

### 8. Squash Migrations Periodically

Consolidate multiple migrations to improve performance and maintainability:

```bash
# ‚úÖ Squash migrations (Django 6.0+)
python manage.py squashmigrations myapp 0001 0010

# ‚úÖ Nested squashing (Django 6.0+)
# You can now squash already-squashed migrations before replacing them
python manage.py squashmigrations myapp 0001_squashed_0010 0020
```

**Squashing Process:**
1. Create squashed migration: `python manage.py squashmigrations myapp 0001 0010`
2. Commit both old and new migrations
3. Deploy and ensure all instances apply the squashed migration
4. Once all instances have applied it, remove old migrations
5. In Django 6.0+, you can squash squashed migrations before replacing them

## ‚ùå DON'T (Forbidden Practices)

### 1. Don't Edit Applied Migrations

Never modify migrations that have been applied to production:

```python
# ‚ùå BAD: Editing applied migration
class Migration(migrations.Migration):
    operations = [
        migrations.AddField(
            model_name='user',
            name='email',
            field=models.EmailField(max_length=255),  # Changed after production
        ),
    ]

# ‚úÖ GOOD: Create new migration instead
class Migration(migrations.Migration):
    dependencies = [
        ('myapp', '0001_initial'),
    ]
    operations = [
        migrations.AlterField(
            model_name='user',
            name='email',
            field=models.EmailField(max_length=255, unique=True),
        ),
    ]
```

### 2. Don't Add Required Fields Without Defaults

Avoid adding non-nullable fields without defaults in production:

```python
# ‚ùå BAD: Non-nullable field without default
migrations.AddField(
    model_name='user',
    name='required_field',
    field=models.CharField(max_length=50),  # Will fail on existing rows
)

# ‚úÖ GOOD: Add nullable first, then populate, then make required
# See django-migrations-production.mdc for two-phase deployment pattern
```

### 3. Don't Call Model Methods in Migrations

Model methods may not be available in historical models:

```python
# ‚ùå BAD: Calling model method (will fail)
from myapp.models import User  # Wrong import

def forwards_func(apps, schema_editor):
    User = apps.get_model('myapp', 'User')
    for user in User.objects.all():
        user.calculate_field()  # AttributeError: method doesn't exist

# ‚úÖ GOOD: Replicate logic in migration function
def calculate_full_name(user):
    return f"{user.first_name} {user.last_name}".strip()

def forwards_func(apps, schema_editor):
    User = apps.get_model('myapp', 'User')
    for user in User.objects.all().iterator():
        user.full_name = calculate_full_name(user)
        user.save(update_fields=['full_name'])
```

### 4. Don't Use Current Model Classes

Never import and use current model classes in migrations:

```python
# ‚ùå BAD: Using current model
from myapp.models import User  # Current model

def forwards_func(apps, schema_editor):
    for user in User.objects.all():
        user.new_field = 'value'
        user.save()  # May raise ValidationError

# ‚úÖ GOOD: Using historical model
def forwards_func(apps, schema_editor):
    User = apps.get_model('myapp', 'User')  # Historical model
    for user in User.objects.all():
        user.new_field = 'value'
        user.save(update_fields=['new_field'])
```

### 5. Don't Drop Columns Immediately After Code Deploy

Use two-phase deployment for destructive changes. See [Production Strategies](django-migrations-production.mdc) for details.

### 6. Don't Mix Schema and Data Changes

Keep schema and data migrations separate:

```python
# ‚ùå BAD: Mixing schema and data
class Migration(migrations.Migration):
    operations = [
        migrations.AddField(...),
        migrations.RunPython(data_migration),  # Should be separate
        migrations.RemoveField(...),
    ]

# ‚úÖ GOOD: Separate migrations
# Migration 1: Schema changes only
# Migration 2: Data migration
# Migration 3: More schema changes
```

### 7. Don't Skip Testing Downgrade

Always test that migrations can be reversed:

```bash
# ‚ùå BAD: Only testing forward migration
python manage.py migrate

# ‚úÖ GOOD: Test both directions
python manage.py migrate
python manage.py migrate myapp 0001  # Test downgrade
python manage.py migrate  # Test upgrade again
```

## üìù Key Points

### Must Have

- **Reversibility**: All migrations must be reversible (provide reverse operations)
- **Descriptive names**: Use `--name` flag for meaningful migration names
- **Testing**: Test both forward and backward migrations before deployment
- **Version control**: Always commit migration files to maintain consistency
- **Historical models**: Use `apps.get_model()` in data migrations, never import current models
- **Dependencies**: Always specify correct dependencies between migrations

### Do

- **Separation**: Separate schema and data migrations into different files
- **Two-phase deployment**: Use two-phase approach for destructive changes (see [Production Strategies](django-migrations-production.mdc))
- **Batch processing**: Process large datasets in batches (see [Data Migrations](django-migrations-data.mdc))
- **Bulk operations**: Use `bulk_update()` and `bulk_create()` for better performance
- **Error handling**: Implement comprehensive error handling in data migrations
- **Squashing**: Periodically squash migrations to improve performance (Django 6.0+ supports nested squashing)
- **Conflict resolution**: Handle migration conflicts with `--merge`
- **Multiple databases**: Check database alias in data migrations when using multiple databases

### Don't

- **Don't edit applied migrations**: Never modify migrations that have been applied to production
- **Don't add required fields without defaults**: Always add nullable first, then populate, then make required
- **Don't call model methods**: Historical models don't have custom methods - replicate logic in migration
- **Don't use current model classes**: Always use `apps.get_model()` to get historical models
- **Don't drop columns immediately**: Use two-phase deployment - remove after code is deployed
- **Don't mix schema and data**: Keep schema changes and data migrations separate
- **Don't skip testing**: Always test both forward and backward migrations
- **Don't process all records at once**: Use batching for large datasets

---

**Remember**: Migrations are a critical part of database schema management. Always prioritize safety, reversibility, and thorough testing, especially for production deployments.
