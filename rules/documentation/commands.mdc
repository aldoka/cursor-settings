---
description: Guide for creating cursor commands - standards and best practices
alwaysApply: false
---

# Guide for Creating Cursor Commands

## üìã Overview

Cursor Commands (`.md` files) are reusable AI prompts stored in `.cursor/commands/` or `commands/` directories that can be invoked via slash commands in Cursor IDE. Commands simplify execution of repetitive tasks by providing brief, action-oriented instructions that reference rules for detailed information.

### Commands vs. Rules

**Commands (`.md` files):**
- **Purpose**: Brief, executable instructions for AI agents
- **Content**: What to do, when to do it, quick reference
- **Length**: Typically 20-50 lines
- **Style**: Imperative, action-oriented
- **References**: Should explicitly reference rules for detailed information

**Rules (`.mdc` files):**
- **Purpose**: IDE-agnostic knowledge, requirements, best practices
- **Content**: What standards to follow, why, examples, constraints
- **Length**: Can be longer (300-500+ lines)
- **Style**: Descriptive, comprehensive
- **Usage**: Referenced by commands, applied automatically by IDE


## ‚úÖ Best Practices (DO)

### 1. Name and Description

- ‚úÖ **Descriptive name**: Command name should clearly describe its purpose
  - ‚úÖ `commit.md` - creating git commit
  - ‚úÖ `code-review.md` - code review
  - ‚úÖ `add-error-handling.md` - adding error handling
  - ‚ùå `cmd1.md`, `test.md`

- ‚úÖ **Kebab-case for file names**: Use kebab-case
  - ‚úÖ `create-command.md`
  - ‚úÖ `refactor-service.md`
  - ‚ùå `createCommand.md`, `refactor_service.md`

- ‚úÖ **Brief description**: First paragraph should briefly describe the command's purpose

### 2. Command Structure

- ‚úÖ **H1 heading**: Start with H1 heading with command name
- ‚úÖ **Links to rules**: Reference related rules (`.mdc` files) for detailed information
- ‚úÖ **Clear instructions**: Give specific, clear instructions
- ‚úÖ **Sequential steps**: Break complex tasks into steps
- ‚úÖ **Checklist**: Include checklist for verification


### 3. Instructions for AI

- ‚úÖ **Imperative style**: Use imperative mood
  - ‚úÖ "Analyze changes"
  - ‚úÖ "Create commit with message"
  - ‚ùå "You can analyze changes"

- ‚úÖ **Specific actions**: Specify concrete actions, not abstractions
  - ‚úÖ "Use `git diff` to analyze changes"
  - ‚ùå "Check changes"

- ‚úÖ **Conditions and constraints**: Specify what to do and what not to do
  ```markdown
  - DO NOT push to remote repository
  - DO NOT create merge commits
  - DO NOT use force push
  ```

### 4. Command Organization

- ‚úÖ **Logical directory structure**: Group commands by categories
  - `commands/utilities/` - utilities (commit, lint, format)
  - `commands/development/` - development (create-component, refactor)
  - `commands/testing/` - testing (add-tests, run-tests)

- ‚úÖ **Versioning**: Store commands in repository for team access
  - Project commands: `.cursor/commands/` or `commands/`
  - Personal commands: `~/.cursor/commands/` (not in repository)

### 5. Length and Readability

- ‚úÖ **Brevity**: Commands should be brief and to the point (typically 20-50 lines)
- ‚úÖ **Focus**: One command = one task
- ‚úÖ **Readability**: Use formatting to improve readability
- ‚úÖ **Reference rules**: For detailed information, reference rules instead of duplicating content
- ‚úÖ **Minimal duplication**: Only include information in commands if it's essential for execution and not available in rules

### 6. Command Updates

- ‚úÖ **Regular review**: Periodically review and update commands
- ‚úÖ **Currency**: Update commands when project practices change

## ‚ùå Anti-patterns (DON'T)

### 1. Avoid

- ‚ùå **Too general commands**: Don't create commands like "improve code"
- ‚ùå **Multiple tasks**: One command should perform one task
- ‚ùå **Unclear instructions**: Avoid vague formulations
- ‚ùå **Missing context**: Don't assume AI knows everything about the project

### 2. Structure

- ‚ùå **Missing heading**: Always start with H1 heading
- ‚ùå **Too long commands**: Avoid commands longer than 100-150 lines
- ‚ùå **Nested structures**: Don't complicate structure unnecessarily

### 3. Instructions

- ‚ùå **Abstract formulations**: Avoid "do well", "improve"
- ‚ùå **Contradictory instructions**: Ensure instructions don't contradict each other
- ‚ùå **Missing constraints**: Specify what not to do

### 4. Organization

- ‚ùå **Flat structure**: Don't put all commands in one directory
- ‚ùå **Unclear names**: Avoid abbreviations

## üîó Linking to Rules

Commands should reference rules for detailed information to avoid duplication and context pollution.

### Principle: Commands Reference Rules

- ‚úÖ **Commands are brief**: Commands should be concise instructions that reference rules
- ‚úÖ **Rules contain details**: All detailed requirements, best practices, and guidelines are in rules
- ‚úÖ **Avoid duplication**: Don't duplicate information from rules into commands
- ‚úÖ **Explicit references**: Commands should explicitly instruct AI to read the referenced rule(s)
- ‚úÖ **Multiple rules support**: Commands can reference single rule, multiple conditional rules, or multiple required rules

### Rule Reference Types

1. **Single rule**: One rule applies to the entire command
2. **Multiple conditional rules**: Different rules apply based on context (framework, environment, etc.)
3. **Multiple required rules**: All listed rules must be read and followed

### Relative Paths

- From `commands/utilities/` to `rules/utilities/`: `../../rules/utilities/`
- From `commands/` to `rules/`: `../rules/`
- From `.cursor/commands/` to `rules/`: `../../rules/`

## üìê Standard Command Structure

```markdown
# command-name

Brief description of the command's purpose (1-2 sentences).

**Links to related rules or context**

## Main Instructions

Detailed instructions for AI on what needs to be done.

**Important points:**
- Key point 1
- Key point 2

## Execution Steps

1. **Step 1**: Step description
2. **Step 2**: Step description
3. **Step 3**: Step description

## Constraints

- DO NOT do X
- DO NOT do Y
- DO NOT do Z

## Checklist

- [ ] Success criterion 1
- [ ] Success criterion 2
- [ ] Success criterion 3
```

## üéØ Examples of Good Commands

### Example 1: Command with steps, single rule, and checklist

```markdown
# add-error-handling

Adding error handling to existing code.

**IMPORTANT: Before starting, read:** [fastapi-exceptions-errors.mdc](../../rules/backend/python/fastapi/fastapi-exceptions-errors.mdc)

## Steps

1. Analyze current code and identify places where error handling is needed
2. Create corresponding domain exceptions if they don't exist
3. Add handling to global error handler if needed
4. Update code to use new exceptions
5. Add error logging

## Constraints

- DO NOT use HTTPException in domain layer
- DO NOT expose internal details in error responses
- DO NOT forget request_id in error responses

## Checklist

- [ ] All error-prone code sections identified
- [ ] Domain exceptions created (if needed)
- [ ] Global error handler updated (if needed)
- [ ] Code updated to use new exceptions
- [ ] Error logging implemented
- [ ] Error responses include request_id
```

### Example 2: Command with multiple conditional rules and checklist

```markdown
# create-component

Creating a new UI component.

**IMPORTANT: Read the appropriate rule based on framework:**

- **React**: Read [react-components.mdc](../../rules/frontend/react/components.mdc)
- **Vue**: Read [vue-components.mdc](../../rules/frontend/vue/components.mdc)
- **Angular**: Read [angular-components.mdc](../../rules/frontend/angular/components.mdc)

Determine the framework from project structure (check package.json, file extensions, or ask user), then read and follow the corresponding rule.

## Steps

1. Identify framework from project structure
2. Read the appropriate component rule
3. Create component following rule guidelines
4. Add component to appropriate location

## Checklist

- [ ] Framework identified correctly
- [ ] Appropriate rule read and understood
- [ ] Component created following rule guidelines
- [ ] Component placed in correct location
- [ ] Component follows project naming conventions
```

### Example 3: Command with multiple required rules and checklist

```markdown
# refactor-service

Refactoring a service following best practices.

**IMPORTANT: Read all relevant rules:**

1. Read [service-patterns.mdc](../../rules/backend/python/fastapi/service-patterns.mdc) for service structure
2. Read [dependency-injection.mdc](../../rules/backend/python/fastapi/dependency-injection.mdc) for DI patterns
3. Read [testing-services.mdc](../../rules/testing/service-tests.mdc) if tests need updates

Follow all referenced rules when refactoring. If tests are affected, read the testing rule as well.

## Steps

1. Read all applicable rules
2. Analyze current service implementation
3. Identify refactoring opportunities
4. Apply patterns from rules
5. Update tests if needed

## Checklist

- [ ] All relevant rules read and understood
- [ ] Current service implementation analyzed
- [ ] Refactoring opportunities identified
- [ ] Patterns from rules applied correctly
- [ ] Tests updated (if needed)
- [ ] Service follows all referenced rule guidelines
```

## üìä Command Creation Checklist

Before creating a new command, ensure:

- [ ] File is placed in correct directory
- [ ] File has descriptive name in kebab-case
- [ ] Command does not dublicate another command, ask user for confirmation if similar command already exists
- [ ] Command is focused on one task
- [ ] Command starts with H1 heading
- [ ] Brief description of purpose is included
- [ ] Links to related rules are added
  - [ ] Single rule reference (if one rule applies)
  - [ ] Multiple rule references (if multiple rules apply)
  - [ ] Conditional rule selection (if rules depend on context)
- [ ] Execution steps are specified
- [ ] Instructions are specific and clear
- [ ] Checklist for verification is included

## üöÄ Command Creation Process

1. **Define task**: What specific task should the command perform?
2. **Check existing**: Are there similar commands already?
3. **Define structure**: What steps are needed for execution?
4. **Write instructions**: Formulate clear instructions for AI
6. **Create checklist**: Define success criteria
7. **Check**: Go through checklist
8. **Test**: Ensure command works correctly

---

**Remember**: A good command is a specific, clear instruction that helps AI effectively perform a task, following project standards. Commands should be brief and reference rules for detailed information to avoid duplication and context pollution.